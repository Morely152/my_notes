--- 
> 声明：本篇笔记部分摘自[《Java核心技术（卷Ⅰ） - 机械工业出版社》](https://detail.tmall.com/item.htm?ali_refid=a3_420434_1006%3A1151895243%3AN%3AoB1xLXSDdjSpCunkFwpZbCtvD%2B6YEaA9%3A39f8fcdda956d1ec63523e9a6e9e2355&id=708821240842&mi_id=0000mg2-P7Ustbzeym2_6DxuUMLCpndkVCAGc5EaA_l8QQ0&mm_sceneid=1_0_128421313_0&priceTId=2147831a17554253371677975e1dca&spm=a21n57.1.hoverItem.2&utparam=%7B%22aplus_abtest%22%3A%226b956865e0df43cd4a6620880d877f11%22%7D&xxc=ad_ztc)及[Java教程-廖雪峰-2025-06-16](https://liaoxuefeng.com/books/java/introduction/index.html)，遵循[CC BY 4.0协议](https://creativecommons.org/licenses/by/4.0/legalcode.zh-hans)。
> 存在由AI生成的小部分内容，仅供参考，请仔细甄别可能存在的错误。

# 一、什么是多线程

想象这么一个摊煎饼的场景，每个煎饼需要以下几个步骤：

```
摊糊糊 -> 烤半分钟 -> 翻面 -> 烤半分钟 -> 出锅
```

现在你有两个煎饼锅（A和B），你一定会这么做：

> 先在A锅中摊糊糊，然后等它烤半分钟的同时在B锅中摊好糊糊，这时候半分钟差不多过去了，给A锅里的煎饼翻个面，然后给B锅翻个面；现在A锅的煎饼两面都煎好了，可以出锅然后继续摊糊糊，这时B锅的煎饼也好了，出锅后A煎饼又可以翻面了…

在现代操作系统中，经常同时运行着多个服务（相当于同时在煎很多个煎饼），特别是在电脑上，我们经常会同时运行多个程序（虽然手机上也有，只不过大多隐藏在后台运行，所以感觉不明显）：

![](20250827173357108.png)

这样同时运行多个服务的技术就称之为“**多线程**”。CPU执行代码都是一条一条顺序执行的，但是，即使是单核cpu，也可以同时运行多个任务。因为操作系统执行多任务实际上就是让CPU对多个任务轮流交替执行。

## 1.进程和线程

在计算机中，我们把一个任务（可以认为是一个APP应用）称为一个进程（Process），例如浏览器就是一个进程，视频播放器是另一个进程，音乐播放器、Word都是一个个的进程。

同时，某些进程内部还需要同时执行多个子任务。例如，微信不仅要接受我们输入的消息内容，还要时刻同步朋友发送过来的信息，我们把这样的子任务称为**线程（Thread）。**

进程和线程的关系就是：一个进程可以包含一个或多个线程，但至少会有一个线程。

```
                        ┌──────────┐
                        │Process   │
                        │┌────────┐│
            ┌──────────┐││ Thread ││┌──────────┐
            │Process   ││└────────┘││Process   │
            │┌────────┐││┌────────┐││┌────────┐│
┌──────────┐││ Thread ││││ Thread ││││ Thread ││
│Process   ││└────────┘││└────────┘││└────────┘│
│┌────────┐││┌────────┐││┌────────┐││┌────────┐│
││ Thread ││││ Thread ││││ Thread ││││ Thread ││
│└────────┘││└────────┘││└────────┘││└────────┘│
└──────────┘└──────────┘└──────────┘└──────────┘
┌──────────────────────────────────────────────┐
│               Operating System               │
└──────────────────────────────────────────────┘
```

操作系统调度的最小任务单位其实不是进程，而是线程。常用的Windows、Linux等操作系统都采用抢占式多任务，如何调度线程完全由操作系统决定，程序自己不能决定什么时候执行，以及执行多长时间。

同一个应用程序可能会有多个进程，也可能会有多个线程。想要同时进行多个服务，可以采取这三种策略：

1. 多进程+进程内单线程
2. 单进程+进程内多线程
3. 多进程+进程内多线程（最复杂）

## 2. 进程与线程的选择

进程和线程是包含关系，但是多任务既可以由多进程实现，也可以由单进程内的多线程实现，还可以混合多进程＋多线程。

具体采用哪种方式，要考虑到进程和线程的特点。和多线程相比，多进程的缺点在于：

- 创建进程比创建线程开销大，尤其是在Windows系统上；
- 进程间通信比线程间通信要慢，因为线程间通信就是读写同一个变量，速度很快。

而多进程的优点在于：

多进程稳定性比多线程高，因为在多进程的情况下，一个进程崩溃不会影响其他进程，而在多线程的情况下，任何一个线程崩溃会直接导致整个进程崩溃。

## 3.Java中的多线程

一个Java程序实际上就是一个JVM进程，JVM进程用一个主线程来执行`main()`方法，在`main()`方法内部，我们又可以启动多个线程。此外，JVM还有负责垃圾回收的其他工作线程等。对于大多数Java程序来说，我们说的多任务，实际上是说如何使用多线程实现多任务。

和单线程相比，多线程编程的特点在于：多线程经常需要读写共享数据，并且需要同步协调进行。比如说播放视频时的播放画面和声音，如果两个线程不协调，视频就会出现音画不同步的问题。多线程编程的复杂的更高，调试也更困难。

但是，多线程编程又非常有用：

- 多线程模型是很多程序设计语言中（包含但不限于Java程序）最基本的并发模型；
- 读写网络、数据库、Web开发等都必须依赖Java多线程模型。

掌握了多线程编程，我们写出的代码的技术含量才会再上一个台阶，才能继续深入学习后续的数据库操作、网络编程等技术。

# 二、创建线程

## 1.线程的创建

要创建一个新线程非常容易，我们只需要实例化一个`Thread`实例，然后调用它的`start()`方法：

```java
// 多线程
public class Demo {
    public static void main(String[] args) {
        Thread t = new Thread();
        t.start(); // 启动新线程
    }
}
```

这个线程上没有什么任务，所以启动后就会立即结束。我们希望让它干点活，那么可以通过以下几种方法实现让新的线程执行一些方法：

**方法一：从`Thread`派生一个自定义类，然后覆写`run()`方法：**

```java
public class Demo {
    public static void main(String[] args) {
        Thread t = new MyThread();
        t.start(); // 启动新线程
    }
}

class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println("start new thread!");
    }
}
```

执行上述代码，注意到`start()`方法会在内部自动调用实例的`run()`方法，输出启动新进程的提示。

**方法二：创建`Thread`实例时，传入一个`Runnable`实例：**

```java
// 多线程
public class Demo {
    public static void main(String[] args) {
        Thread t = new Thread(new MyRunnable());
        t.start(); // 启动新线程
    }
}

class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println("start new thread!");
    }
}
```

我们也可以用Java 8引入的lambda语法进一步简写为：

```java
// 多线程
public class Demo {
    public static void main(String[] args) {
        Thread t = new Thread(() -> {
            System.out.println("start new thread!");
        });
        t.start(); // 启动新线程
    }
}
```

## 2.线程优先级

设定优先级的方法是：

```java
Thread.setPriority(int n) // 1~10, 默认值5
```

JVM自动把1（低）~10（高）的优先级映射到操作系统实际优先级上需要注意的是虽然操作系统对高优先级线程可能调度得更频繁，但我们无法通过设置优先级来确保高优先级的线程一定会先执行。

# 三、线程的状态

在Java程序中，一个线程对象只能调用一次`start()`方法启动新线程，并在新线程中执行`run()`方法。一旦`run()`方法执行完毕，线程就结束了。因此，Java线程的状态有以下几种：

- New：新创建的线程，尚未执行；
- Runnable：运行中的线程，正在执行`run()`方法的Java代码；
- Blocked：运行中的线程，因为某些操作被阻塞而挂起；
- Waiting：运行中的线程，因为某些操作在等待中；
- Timed Waiting：运行中的线程，因为执行`sleep()`方法正在计时等待；
- Terminated：线程已终止，因为`run()`方法执行完毕。

当线程启动后，它可以在`Runnable`、`Blocked`、`Waiting`和`Timed Waiting`这几个状态之间切换，直到最后变成`Terminated`状态，线程终止。

线程终止的原因有这么几种：

- 线程正常终止：`run()`方法执行到`return`语句返回；
- 线程意外终止：`run()`方法因为未捕获的异常导致线程终止；
- 对某个线程的`Thread`实例调用`stop()`方法强制终止（不推荐使用）。

一个线程还可以等待另一个线程直到其运行结束。例如，`main`线程在启动`t`线程后，可以通过`t.join()`等待`t`线程结束后再继续运行，相当于是在`t`后面“排队”。

```java
public class Demo {  
    public static void main(String[] args) throws InterruptedException {  
        Thread t = new Thread(() -> {  
            System.out.println("t线程运行中…");    // 这里是t线程的任务  
            System.out.println("t线程任务完成");  
        });  
        System.out.println("主线程开始运行");  
        t.start();                       // 启动t线程  
        t.join();                        // 此处main线程会等待t的结束  
        System.out.println("主线程结束运行");  
    }  
}

/*输出结果：
主线程开始运行
t线程运行中…
t线程任务完成
主线程结束运行
*/
```

当`main`线程调用线程`t`的`join()`方法时，主线程将等待变量x线程`t`结束后，才继续往下执行自身线程。所以，上述代码打印顺序可以肯定是`main`线程先打印`start`，`t`线程再打印`hello`，`main`线程最后再打印`end`。

> 就像火车站里并排铺设的一条条轨道，并行的多线程就如同铁轨上一辆辆呼啸而过的火车。如何对这些火车进行“**调度**”，确保乘客上下车准确无误（进程间通信），是我们需要考虑的问题。

# 四、中断线程

试想这样一个情景：你点击下载了一个文件，创建下载任务后发现文件大小为10GB，此时由于心疼流量/内存不够/下载太慢，你决定放弃下载，于是点击了下载管理器中的“取消”按钮。对于浏览器来说，此时已经没有必要继续下载了，需要**提前结束**这个尚未完成的下载线程。

提前结束一个未完成的线程，就是线程的**中断**操作。

## 1.interrupt()方法

中断一个Java线程非常简单，只需要在其他线程中对目标线程调用`interrupt()`方法。目标线程一旦发现自己的`interrupt()`方法被调用，就会立刻结束自身线程。

```java
public class Demo {  
    public static void main(String[] args) throws InterruptedException {  
        System.out.println("+++++主线程开始");  
        Thread t = new MyThread();  
        t.start();  
        Thread.sleep(1000); // 暂停1秒  
        t.interrupt(); // 中断t线程  
        t.join(); // 等待t线程结束  
        System.out.println("+++++主线程结束");  
    }  
}  
  
class MyThread extends Thread {  
    public void run() {  
        System.out.println("-----t线程开始");  
        int n = 0;  
        while (!isInterrupted()) {  
            n ++;  
            System.out.println(" hello! x " + n);  
            try {  
                Thread.sleep(200); // 暂停0.2秒  
            } catch (InterruptedException e) {  
                System.out.println("-----t线程中断退出");  
                break;  
            }  
        }  
        System.out.println("-----t线程结束");  
    }  
}

/*运行结果：
+++++主线程开始
-----t线程开始
 hello! x 1
 hello! x 2
 hello! x 3
 hello! x 4
 hello! x 5
-----t线程中断退出
-----t线程结束
+++++主线程结束
*/
```

在这个例子中，JVM先启动了主线程，然后主线程又启动了t线程并且暂停等待一秒钟；t线程启动后每过0.2秒执行一次 `n++` 并且输出一个 `hello x n`，直到一秒钟后主线程继续运行，触发了t线程的中断并且等待t线程处理完毕。t线程一共执行 1 / 0.2 = 5 次之后结束，因此会输出到 `hello x 5` 结束；此时t线程捕获了中断异常，在catch语句中输出了线程中断消息并且退出了循环，因此线程结束。被`t.join()`阻塞的主线程解除阻塞，得以继续运行，输出“主线程结束”的消息后也运行完毕，自动结束了运行。

> 类似于老板说马上开会，让我们去打印文件（主线程启动子线程）；我们每0.2分钟打打印好一份（子线程处理任务），老板一分钟之后跟我们说没时间了，让我们不管打了多少份都交到会议室去（主线程中断子线程，并且等待子线程处理完成）；我们到达会议室后，老板分发文件并且开始会议（子线程处理完毕，主线程阻塞解除，继续处理后续任务）。

需要注意的是，如果线程被中断时处于等待（阻塞）状态，例如，`t.join()`会让`main`线程进入等待状态，此时，如果对`main`线程调用`interrupt()`，`join()`方法会立刻抛出`InterruptedException`。因此，目标线程只要捕获到`join()`方法抛出的`InterruptedException`，就说明有其他线程对其调用了`interrupt()`方法，通常情况下该线程应该立刻结束运行。

## 2.使用标志实现中断

另外一种中断控制方法是给线程对象定义一个`public volatile boolean running`字段，在外部线程中把`thread.running`置为`false`，就可以让线程结束。注意这里不仅要标注成`boolean`类型，还要使用`volatile`关键字标记，确保每个线程都能读取到更新后的变量值。

JVM会把变量的值保存在主内存中。一个线程访问变量时，实际上是将变量拷贝一份到自己的工作内存中。如果其他线程修改了自己内存中的值而还没有同步到主内存中，数据的改变就不同步了。因此需要`volatile`关键字来明确告知JVM，每次在访问变量时从主内存读取最新的值，并且在修改拷贝的变量后立即写回到主内存中。

# 五、守护线程

Java程序启动时，会先启动主线程，主线程再启动其他线程。当所有的线程都运行结束是，程序就结束了，此时JVM也会退出，整个Java进程随之终止。

有些情况下，我们需要通过一个线程来执行一些周期性的任务，这些任务通常是放在死循环中执行的，即这个进程不会自动停止，也没有一个机制来自动管理；想要维护这样的程序就比较困难。

这个时候就轮到**守护线程**（Daemon Thread）发挥作用了。在JVM中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。

创建守护线程的方法和普通线程一样，只是需要再调用`start()`之前调用`setDaemon(true)`即可。

```java
Thread t = new MyThread();
t.setDaemon(true);
t.start();
```

因此，对之前的那个在子线程中打印`hello`的例子，还可以这样写：

```java
public class Demo {  
    public static void main(String[] args) throws InterruptedException {  
        System.out.println("+++++主线程开始");  
        Thread t = new MyThread();  
        t.setDaemon(true);       // 标记为守护线程  
        t.start();  
        Thread.sleep(1000); // 暂停1秒  
        System.out.println("+++++主线程结束");  
    }  
}  
  
class MyThread extends Thread {  
    public void run() {  
        System.out.println("-----t线程开始");  
        int n = 0;  
        while (!isInterrupted()) {  
            n ++;  
            System.out.println(" hello! x " + n);  
            try {  
                Thread.sleep(200); // 暂停0.2秒  
            } catch (InterruptedException e) {  
                System.out.println("-----t线程中断退出");  
                break;  
            }  
        }  
        System.out.println("-----t线程结束");  
    }  
}
/*输出结果：
+++++主线程开始
-----t线程开始
 hello! x 1
 hello! x 2
 hello! x 3
 hello! x 4
 hello! x 5
+++++主线程结束
*/
```

通过将`t`线程标记为守护线程，就无需在主线程中对`t`线程执行中断操作了，只需要直接结束主线程即可；此时JVM检测到所有非守护线程都已经结束，就会自动停止守护线程，然后自己也退出运行。略有不同的是，这里主线程退出后不会触发t线程的中断异常，t线程会立即被JVM停止，因此不会输出“t线程被中断”、“t线程结束”这样的信息。

如果没有将t线程标记为守护线程，也没有在主线程中让它及时中断，就会输出这样的内容：

``` 
+++++主线程开始
-----t线程开始
 hello! x 1
 hello! x 2
 hello! x 3
 hello! x 4
 hello! x 5
+++++主线程结束
 hello! x 6
 hello! x 7
 hello! x 8
 hello! x 9
 hello! x 10
...以下省略...
```

可以发现此时即使主线程任务完成后停止了，但是t线程由于是死循环仍然会继续运行下去。

# 六、线程同步

```java
public class Demo {  
    public static int cnt = 0;  
  
    public static void main(String[] args) {  
        Adder adder = new Adder();  
        Suber suber = new Suber();  
          
        adder.start();  
        suber.start();  
    }  
}  
  
class Adder extends Thread {  
    public void run() {  
        for (int i = 0; i < 10000; i++) {  
            Demo.cnt = Demo.cnt + 1;  
	            System.out.println(i + ":Adder:cnt的值为" + Demo.cnt);  
        }  
    }  
}  
  
class Suber extends Thread {  
    public void run() {  
        for (int i = 0; i < 10000; i++) {  
            Demo.cnt = Demo.cnt - 1;  
            System.out.println(i + ":Suber:cnt的值为" + Demo.cnt);  
        }  
    }  
}
```

上面这段程序定义了两个线程对象，启动后分别对公有变量`cnt`自增/自减10000次，预期的结果是0，但是实际运行后，可能会得到这样的结果：

```
0:Adder:cnt的值为1
1:Adder:cnt的值为1
0:Suber:cnt的值为0
1:Suber:cnt的值为1
2:Adder:cnt的值为2
...中间省略...
9996:Adder:cnt的值为-17
9997:Adder:cnt的值为-16
9998:Adder:cnt的值为-15
9999:Adder:cnt的值为-14
```

最后得到的值其实也不确定，虽然大多数情况下是 $0$，但有时候会有 $\pm2$ 的误差，甚至会出现 $12$、$-14$ 这样误差很大的值。（我怀疑是`a=a+1`的问题，尝试替换成`a++`、`a+=1`这样的写法仍然存在这样的问题。）这是因为对于这样的自增/自减操作，实际上由三步组成：

```java
n = n + 1;

/*
step1：ILOAD  -> 取出n的值
step2: IADD   -> 递增n的值
step3：ISTORE -> 写回n的值
*/
```

尽管多线程似乎是同时进行的，但是在操作系统中实际上是通过进程中断，在多个进程之间来回切换处理的。这样一来，如果两个进程同时对一个变量进行迭加操作（100+1）时，可能会出现这样的情况：

```
┌───────┐     ┌───────┐
│Thread1│     │Thread2│
└───┬───┘     └───┬───┘
    │             │
    │ILOAD (100)  │
    │             │ILOAD (100)
    │             │IADD
    │             │ISTORE (101)
    │IADD         │
    │ISTORE (101) │
    ▼             ▼
```

线程1读取变量的值（100）后被操作系统中断，线程2读取变量的值（100），然后递增并写回新的值（101），此时操作系统回头处理线程1，将变量的值（100）递增并写回新值（101）。看似是两个线程都执行了+1的操作，因此会得到102，但实际上两个线程获取到的是相同的旧值，**分别**进行了+1的操作，而不是**先后**进行的。

## 1.`synchronized`同步锁

### ① 初识同步锁

这说明多线程模型下，要保证逻辑正确，对共享变量进行读写时，必须保证一组指令以原子方式（仅有一步操作，或者多个操作之间不得中断，必须将他们视为一个最小的单位“原子”）执行。我们可以考虑用一把“**锁**”让这些进程的最小逻辑组成一个独立的单位，操作系统必须处理完整个单元后才能够中断这个线程去处理其他的线程。

```
┌───────┐     ┌───────┐
│Thread1│     │Thread2│
└───┬───┘     └───┬───┘
    │             │
    │-- lock --   │
    │ILOAD (100)  │
    │IADD         │
    │ISTORE (101) │
    │-- unlock -- │
    │             │-- lock --
    │             │ILOAD (101)
    │             │IADD
    │             │ISTORE (102)
    │             │-- unlock --
    ▼             ▼
```

这种加锁和解锁之间的代码块我们称之为**临界区**（Critical Section），临界区内不得对线程进行中断处理（即使在临界区内中断线程，也只能等到线程触发中断异常或者临界区的逻辑执行完毕才能停止）。可见，**保证一段代码的原子性，就是通过加锁和解锁实现的**。Java程序使用`synchronized`关键字（中文释义为“同步的”）对线程的一些操作加锁：

```java
synchronized(lock) {
    n = n + 1;
}
```

现在我们把之前的例子进行修改，通过“锁”来解决这个问题：

```java
public class Demo {  
    public static int cnt = 0;  
    public static final Object lock = new Object(); // 创建一个锁的实例  
  
    public static void main(String[] args) {  
        Adder adder = new Adder();  
        Suber suber = new Suber();  
          
        adder.start();  
        suber.start();  
    }  
}  
  
class Adder extends Thread {  
    public void run() {  
        for (int i = 0; i < 10000; i++) {  
            synchronized (Demo.lock) {            // 上锁
                Demo.cnt+=1;  
                System.out.println(i + ":Adder:cnt的值为" + Demo.cnt);  
            }  
        }  
    }  
}  
  
class Suber extends Thread {  
    public void run() {  
        for (int i = 0; i < 10000; i++) {  
            synchronized (Demo.lock) {            // 上锁  
                Demo.cnt-=1;  
                System.out.println(i + ":Suber:cnt的值为" + Demo.cnt);  
            }  
        }  
    }  
}
```

注意`synchronized (Demo.lock) { ... } `中的参数，表示**用`Demo.lock`实例**作为锁，两个线程在运行到各自的临界区时，必须先获得锁才能进入临界区内继续运行。执行结束后，在`synchronized`语句块结束会自动释放锁。这样一来，对`Demo.count`变量的增减与读写操作就成为了一个最小的代码单元，不能被随意中断。修改后的代码无论运行多少次，最终结果都是0。

### ② 同步锁的缺点及注意事项

虽然使用`synchronized`解决了多线程同步访问共享变量的正确性问题，但它的缺点是带来了性能的下降。`synchronized`代码块无法并发执行，而且加锁和解锁需要消耗一定的时间。大量使用`synchronized`会降低程序的执行效率。

还需要注意的是，我们可以定义多个`Object`的实例作为锁，在读写不同的公共变量时使用不同的锁，既可以避免同步读写造成的数据错误，又可以防止多个线程共同竞争同一个锁造成的效率降低。例如，有两个公共变量`var1`和`var2`，我们需要定义两把锁`lock1`和`lock2`，将读写`var1`的所有方法都使用`lock1`锁住，读写`var2`的所有方法都使用`lock2`锁住。

### ③ 不需要同步锁的情况

JVM的规范定义了几种原子操作：

- 基本类型（`long`和`double`除外）赋值。`long`和`double`是64位数据，JVM没有明确规定64位赋值操作是不是一个原子操作。
- 引用类型赋值，例如：`List<String> list = anotherList`。

单个原子操作无需加锁，但是多个连续的原子操作（读取-修改-写入）一般需要加锁，最好连同多个变量的赋值/写入也用锁固定流程，防止出现逻辑错误。

此外，无需在读写不可变对象（String等）时加锁。

## 2.同步方法

我们知道锁的原理是在主类中定义一个`Object lock`实例，让这个实例每次只能被同一个`synchronized(Demo.lock)`方法获取，从而避免挂上同一把锁的这些线程操作同时进行。

但是有些时候我们只是不希望线程中的一部分操作被意外打断，或者有很多这样的原子操作需要用锁保护，这样会需要在主类中定义大量的实例同步锁，而且很多锁的利用率其实并不高，这样无形中增加了主类和线程类之间的耦合度，也让代码的维护变得更困难。

更好的方法是把`synchronized`逻辑封装起来,将对同一个变量的读写操作封装到一起。让我们这样修改之前的例子：

```java
public class Demo {  
    public static void main(String[] args) {  
        Counter counter = new Counter();  
  
        Thread addThread = new Thread(() -> {  
            counter.adder();  
        });  
        addThread.start();  
  
        Thread subThread = new Thread(() -> {  
            counter.suber();  
        });  
        subThread.start();  
          
    }  
}  
  
class Counter{  
    public int cnt = 0;  
  
    public void adder() {  
        synchronized (this) {  
            for (int i = 0; i < 10000; i++) {  
                cnt++;  
                System.out.println(i + ":adder:cnt的值为" + cnt);  
            }  
        }  
    }  
  
    public void suber() {  
        synchronized (this) {  
            for (int i = 0; i < 10000; i++) {  
                cnt--;  
                System.out.println(i + ":suber:cnt的值为" + cnt);  
            }  
        }  
    }  
  
}
```

这里不再定义两个线程类`Adder`和`Suber`，而是将它们作为方法，将主类的字段`cnt`作为一个属性，一起封装成一个单独的类`Counter`，然后在main方法中实例化两个线程对象`adderThread`和`suberThread`，分别调用`counter`的两个方法来实现数据的读写；由于这两个方法的同步锁参数均为`this`，即`counter`实例本身，也能很好地防止同步读写造成的数据错误。这个例子无论运行多少次，结果也是稳定的0。

实际上如果需要通过`synchronized (this)`锁住整个方法，也可以直接用`synchronized`修饰这个方法。例如上面的`Counter.adder()`可以写成这样：

```java
public synchronized void adder() {  
        for (int i = 0; i < 10000; i++) {  
            cnt++;  
            System.out.println(i + ":adder:cnt的值为" + cnt);  
        }  
}
```

### 线程安全

如果一个类被设计为允许多线程正确访问，我们就说这个类就是“**线程安全**”（thread-safe）的，例如上面的`Counter`类就是线程安全的。之前提到Java标准库中的`java.lang.StringBuffer`是多线程的，这个类也是线程安全的。

还有一些不变类，例如`String`，`Integer`，`LocalDate`，它们的所有成员变量都是`final`，多线程同时访问时只能读不能写，这些不变类也是线程安全的。而且类似`Math`这些只提供静态方法，没有成员变量的类，也是线程安全的。

除了上述情况以外，大多数的类例如`ArrayList`，都是非线程安全的类，不能在多线程中修改它们。我们默认一个类是非线程安全的。

## 3.死锁

![](20250903033103454.png#sc)

有两个上锁的箱子，但是打开它们的钥匙在对方的箱子里。如果我们想要打开A箱子，就必须在B箱子中拿出A的钥匙；可是B箱子的钥匙在A箱子中。这样一来，两个箱子我们都无法解开，这就是一种“**死锁**”（Deadlock）现象。

**死锁是指两个或多个进程（或线程）在执行过程中，因争夺资源而陷入的一种相互等待的状态**。若无外力干涉，这些进程都无法向前推进。死锁通常需要满足以下四个必要条件：

1. **互斥条件**（Mutual Exclusion）：资源一次只能被一个进程占用。
    
2. **占有并等待**（Hold and Wait）：进程已经占有了至少一个资源，并等待获取其他进程占有的资源。
    
3. **不可抢占**（No Preemption）：资源只能由持有它的进程自愿释放，不能被强制抢占。
    
4. **循环等待**（Circular Wait）：存在一个进程等待链，每个进程都在等待下一个进程所持有的资源。
### ① 可重入锁

```java
public class Counter {
    private int count = 0;

    public synchronized void add(int n) {
        if (n < 0) {
            dec(-n);
        } else {
            count += n;
        }
    }

    public synchronized void dec(int n) {
        count += n;
    }
}
```

考虑上面这样一个例子，当某个线程成功调用了`add()`方法时，它已经或得到了`this`锁，但是执行`add()`方法时可能还会调用`dec()`方法；但是这个方法同样需要该线程获取这个相同的`this`锁，并且在Java中也是允许这样做的。JVM允许同一个线程重复获取同一个锁，这种能被同一个线程反复获取的锁，就叫做**可重入锁**。

因此，所以在获取锁的时候，不但要判断是否是第一次获取，还要记录这是第几次获取。每获取一次锁，记录+1，每退出`synchronized`块，记录-1，减到0的时候，才会真正释放锁。