--- 
> 声明：本篇笔记部分摘自[《Java核心技术（卷Ⅰ） - 机械工业出版社》](https://detail.tmall.com/item.htm?ali_refid=a3_420434_1006%3A1151895243%3AN%3AoB1xLXSDdjSpCunkFwpZbCtvD%2B6YEaA9%3A39f8fcdda956d1ec63523e9a6e9e2355&id=708821240842&mi_id=0000mg2-P7Ustbzeym2_6DxuUMLCpndkVCAGc5EaA_l8QQ0&mm_sceneid=1_0_128421313_0&priceTId=2147831a17554253371677975e1dca&spm=a21n57.1.hoverItem.2&utparam=%7B%22aplus_abtest%22%3A%226b956865e0df43cd4a6620880d877f11%22%7D&xxc=ad_ztc)及[Java教程-廖雪峰-2025-06-16](https://liaoxuefeng.com/books/java/introduction/index.html)，遵循[CC BY 4.0协议](https://creativecommons.org/licenses/by/4.0/legalcode.zh-hans)。
> 存在由AI生成的小部分内容，仅供参考，请仔细甄别可能存在的错误。

# 一、什么是多线程

想象这么一个摊煎饼的场景，每个煎饼需要以下几个步骤：

```
摊糊糊 -> 烤半分钟 -> 翻面 -> 烤半分钟 -> 出锅
```

现在你有两个煎饼锅（A和B），你一定会这么做：

> 先在A锅中摊糊糊，然后等它烤半分钟的同时在B锅中摊好糊糊，这时候半分钟差不多过去了，给A锅里的煎饼翻个面，然后给B锅翻个面；现在A锅的煎饼两面都煎好了，可以出锅然后继续摊糊糊，这时B锅的煎饼也好了，出锅后A煎饼又可以翻面了…

在现代操作系统中，经常同时运行着多个服务（相当于同时在煎很多个煎饼），特别是在电脑上，我们经常会同时运行多个程序（虽然手机上也有，只不过大多隐藏在后台运行，所以感觉不明显）：

![](20250827173357108.png)

这样同时运行多个服务的技术就称之为“**多线程**”。CPU执行代码都是一条一条顺序执行的，但是，即使是单核cpu，也可以同时运行多个任务。因为操作系统执行多任务实际上就是让CPU对多个任务轮流交替执行。

## 1.进程和线程

在计算机中，我们把一个任务（可以认为是一个APP应用）称为一个进程（Process），例如浏览器就是一个进程，视频播放器是另一个进程，音乐播放器、Word都是一个个的进程。

同时，某些进程内部还需要同时执行多个子任务。例如，微信不仅要接受我们输入的消息内容，还要时刻同步朋友发送过来的信息，我们把这样的子任务称为**线程（Thread）。**

进程和线程的关系就是：一个进程可以包含一个或多个线程，但至少会有一个线程。

```
                        ┌──────────┐
                        │Process   │
                        │┌────────┐│
            ┌──────────┐││ Thread ││┌──────────┐
            │Process   ││└────────┘││Process   │
            │┌────────┐││┌────────┐││┌────────┐│
┌──────────┐││ Thread ││││ Thread ││││ Thread ││
│Process   ││└────────┘││└────────┘││└────────┘│
│┌────────┐││┌────────┐││┌────────┐││┌────────┐│
││ Thread ││││ Thread ││││ Thread ││││ Thread ││
│└────────┘││└────────┘││└────────┘││└────────┘│
└──────────┘└──────────┘└──────────┘└──────────┘
┌──────────────────────────────────────────────┐
│               Operating System               │
└──────────────────────────────────────────────┘
```

操作系统调度的最小任务单位其实不是进程，而是线程。常用的Windows、Linux等操作系统都采用抢占式多任务，如何调度线程完全由操作系统决定，程序自己不能决定什么时候执行，以及执行多长时间。

同一个应用程序可能会有多个进程，也可能会有多个线程。想要同时进行多个服务，可以采取这三种策略：

1. 多进程+进程内单线程
2. 单进程+进程内多线程
3. 多进程+进程内多线程（最复杂）

## 2. 进程与线程的选择

进程和线程是包含关系，但是多任务既可以由多进程实现，也可以由单进程内的多线程实现，还可以混合多进程＋多线程。

具体采用哪种方式，要考虑到进程和线程的特点。和多线程相比，多进程的缺点在于：

- 创建进程比创建线程开销大，尤其是在Windows系统上；
- 进程间通信比线程间通信要慢，因为线程间通信就是读写同一个变量，速度很快。

而多进程的优点在于：

多进程稳定性比多线程高，因为在多进程的情况下，一个进程崩溃不会影响其他进程，而在多线程的情况下，任何一个线程崩溃会直接导致整个进程崩溃。

## 3.Java中的多线程

一个Java程序实际上就是一个JVM进程，JVM进程用一个主线程来执行`main()`方法，在`main()`方法内部，我们又可以启动多个线程。此外，JVM还有负责垃圾回收的其他工作线程等。对于大多数Java程序来说，我们说的多任务，实际上是说如何使用多线程实现多任务。

和单线程相比，多线程编程的特点在于：多线程经常需要读写共享数据，并且需要同步协调进行。比如说播放视频时的播放画面和声音，如果两个线程不协调，视频就会出现音画不同步的问题。多线程编程的复杂的更高，调试也更困难。

但是，多线程编程又非常有用：

- 多线程模型是很多程序设计语言中（包含但不限于Java程序）最基本的并发模型；
- 读写网络、数据库、Web开发等都必须依赖Java多线程模型。

掌握了多线程编程，我们写出的代码的技术含量才会再上一个台阶，才能继续深入学习后续的数据库操作、网络编程等技术。

# 二、创建线程

## 1.线程的创建

要创建一个新线程非常容易，我们只需要实例化一个`Thread`实例，然后调用它的`start()`方法：

```java
// 多线程
public class Demo {
    public static void main(String[] args) {
        Thread t = new Thread();
        t.start(); // 启动新线程
    }
}
```

这个线程上没有什么任务，所以启动后就会立即结束。我们希望让它干点活，那么可以通过以下几种方法实现让新的线程执行一些方法：

**方法一：从`Thread`派生一个自定义类，然后覆写`run()`方法：**

```java
public class Demo {
    public static void main(String[] args) {
        Thread t = new MyThread();
        t.start(); // 启动新线程
    }
}

class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println("start new thread!");
    }
}
```

执行上述代码，注意到`start()`方法会在内部自动调用实例的`run()`方法，输出启动新进程的提示。

**方法二：创建`Thread`实例时，传入一个`Runnable`实例：**

```java
// 多线程
public class Demo {
    public static void main(String[] args) {
        Thread t = new Thread(new MyRunnable());
        t.start(); // 启动新线程
    }
}

class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println("start new thread!");
    }
}
```

我们也可以用Java 8引入的lambda语法进一步简写为：

```java
// 多线程
public class Demo {
    public static void main(String[] args) {
        Thread t = new Thread(() -> {
            System.out.println("start new thread!");
        });
        t.start(); // 启动新线程
    }
}
```

## 2.线程优先级

设定优先级的方法是：

```java
Thread.setPriority(int n) // 1~10, 默认值5
```

JVM自动把1（低）~10（高）的优先级映射到操作系统实际优先级上需要注意的是虽然操作系统对高优先级线程可能调度得更频繁，但我们无法通过设置优先级来确保高优先级的线程一定会先执行。

