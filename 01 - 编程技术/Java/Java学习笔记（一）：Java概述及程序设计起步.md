---

---
--- 
> 声明：本篇笔记部分摘自[《Java核心技术（卷Ⅰ） - 机械工业出版社》](https://detail.tmall.com/item.htm?ali_refid=a3_420434_1006%3A1151895243%3AN%3AoB1xLXSDdjSpCunkFwpZbCtvD%2B6YEaA9%3A39f8fcdda956d1ec63523e9a6e9e2355&id=708821240842&mi_id=0000mg2-P7Ustbzeym2_6DxuUMLCpndkVCAGc5EaA_l8QQ0&mm_sceneid=1_0_128421313_0&priceTId=2147831a17554253371677975e1dca&spm=a21n57.1.hoverItem.2&utparam=%7B%22aplus_abtest%22%3A%226b956865e0df43cd4a6620880d877f11%22%7D&xxc=ad_ztc)，遵循[CC BY 4.0协议](https://creativecommons.org/licenses/by/4.0/legalcode.zh-hans)。这本书以及这个系列的笔记会将Java与一些编程语言的特性作比较；建议拥有一定的C/C++或其他编程语言的学习基础后，再阅读这本书或这个系列的笔记来学习Java。如果是第一次接触编程语言，建议从相对简单的C语言或Python开始；或者参考一些体系化的视频课程来进行学习，否则会感到有一定的压力。
> 存在由AI生成的小部分内容，仅供参考，请仔细甄别可能存在的错误。

# 一、Java的发展史

## **1. 起源（1991–1995）**

- **项目名称**：最初由**James Gosling**（詹姆斯·高斯林）在Sun Microsystems（太阳微系统公司）领导开发，命名为**Oak**（橡树），目标是为嵌入式设备（如电视机顶盒）设计一种便携语言。
- **改名Java**：因商标冲突，1995年更名为**Java**（灵感来自印尼爪哇岛的咖啡，因此Logo是一杯咖啡）。
- **互联网机遇**：随着互联网兴起，Java的**跨平台特性**（通过JVM实现"一次编写，到处运行"）使其迅速成为Web开发的热门选择。

## **2. 正式发布（1995–2000）**

- **1995年**：Sun发布**Java 1.0**，强调**Applet**（在浏览器中运行的小程序），推动早期Web动态交互。
- **1996年**：JDK 1.0（Java Development Kit）发布，包含核心库和JVM。
- **企业级扩展**：1999年推出**J2EE**（Java 2 Platform Enterprise Edition），支持企业应用开发（如Servlet、EJB）。

## **3. 成熟与开源（2000–2010）**

- **版本演进**：
    - J2SE 1.4（2002）：引入**NIO**、正则表达式等。
    - Java 5（2004）：重大更新，支持**泛型**、**注解**、**枚举**等。
- **开源化**：2006年Sun将Java部分开源，2007年完成全部开源（OpenJDK）。
- **2009年**：Oracle收购Sun Microsystems，成为Java的主要维护者。

## **4. 现代Java（2010至今）**

- **版本加速**：
    - **Java 8**（2014）：里程碑版本，引入**Lambda表达式**、**Stream API**、**新的日期时间API**。
    - **Java 11**（2018）：首个长期支持（LTS）版本，Oracle调整发布周期（每半年一版，每3年一个LTS）。
    - **Java 17**（2021）：最新LTS版本，增强模式匹配、密封类等。
- **生态繁荣**：Spring框架、Android开发（早期基于Java）、大数据（Hadoop）等广泛应用。

## [Java白皮书](https://www.oracle.com/java/technologies/javase/javase-whitepapers.html)上提到的11个关键术语

- 简单性
- 面向对象
- 分布式
- 健壮性
- 安全性
- 体系结构和中立
- 可移植性
- 解释性
- 高性能
- 多线程
- 动态性

# 二、Hello World!

像学习其他的编程语言一样，从最简单的输出"Hello World！"开始：

```java
// HelloWorld.java

public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello World!");
    }
}
```

仔细分析一下这段程序：通过访问修饰符`publlic`定义了一个公有的类`HelloWorld`，其中有一个`main`方法，通过`system.out.println()`打印了`"Hello World!"`这么一个字符串。需要注意以下几点：

- 必须存在一个公共类与源代码的文件名相同，作为程序的入口；类似于C/C++中的main函数；并且该类中必须包含一个main方法，且该方法也必须声明为`public`。（在VS Code中修改主类或文件名的名称，文件名或主类的名称也会自动跟随修改）
- 类的标准命名方式为**驼峰命名法**，即所有单词的首字母均大写；Java区分大小写，`main`和`Main`不同。
- **类**是Java应用的构建模块，所有的Java程序都必须放在类中。
- 语句结束的标志不是回车而是`;`，有必要的情况下可以使用回车编写一个多行的语句。
- `system.out.println()`方法会在打印之后自动换行，相比之下`system.out.print()`方法会把新的内容打印在同一行中。

作为初学者，或许会对`main`方法的参数`String[] args`感到疑惑，这里做出解释：

> 当我们运行Java程序时，可以在命令行（或终端）后面附加参数，这些参数会被传递给`main`方法，如`java HelloWorld arg1 arg2 arg3`，这里的`agr1 arg2 arg3`会作为字符串数组`String[]`传进`main`方法。Java规范要求`main`方法的签名必须如此，作为程序的统一入口点。即使我们不使用它，也需要声明，否则JVM无法识别`main`方法。

# 三、注释

与C/C++类似，Java中的注释也有这两种方式：

```java
// 单行注释

/*
	多行注释
	多行注释
	多行注释
*/
```

# 四、基本数据类型

Java是一种**强类型语言**，即必须为每一个变量声明一个类型。在Java中，一共有8种数据类型（4整型+2浮点型+1字符型+1布尔型）。

## 1.整型

表示没有小数的数字，可以为负。

| 类型    | 大小    | 取值范围                                                   |
| ----- | ----- | ------------------------------------------------------ |
| int   | 4 bit | -2 147 483 648 ~ 2 147 483 647                         |
| short | 2 bit | -32 768 ~ 32 767                                       |
| long  | 8 bit | -9 223 372 036 854 775 808 ~ 9 223 372 036 854 775 807 |
| byte  | 1 bit | -128 ~ 127                                             |

在Java中，整型的取值范围与运行平台无关，这使得Java有较好的可移植性；一定程度上避免了C/C++在不同的机器上可能存在的溢出问题。

长整型的数据末尾有一个L或者l，十六进制前面有0x或0x，八进制的前缀是0（如8 -> 010），这种写法容易混淆所以使用得比较少。二进制数的前缀是0b或0B。数字很大时，可以加上下划线使其更易读，如2_147_483_647。

## 2.浮点型

表示有小数部分的数值，与C/C++类似有两种类型：

| 类型     | 大小    | 取值范围                                              |
| ------ | ----- | ------------------------------------------------- |
| long   | 4 bit | 约 $\pm3.402 823 47\times10^{38}$（6~7位有效数字）        |
| double | 8 bit | 约 $\pm1.79769313486231570\times10^{308}$（15位有效数字） |

double表示的数值精度是float的两倍，因此也有“双精度浮点数”的说法。大多数情况下，都会使用double类型存储浮点数。在一个数后面加上d、D或者f、F，可以分别标识为单精度或双精度。

在浮点数中，有三个特殊数值表示溢出或错误：

- POSITIVE_INFINITY：正无穷大
- NEGATIVE_INFINITY：负无穷大
- NaN：非数字

例如，一个非零数除以零会得到无穷大的结果，而0除以0或者负数开偶次方根会得到NaN。需要注意的是，NaN不等于任何值，包括它自己，因此无法通过与NaN比较来判断结果不为NaN，而是应该使用`Double.isNaN(x)`。

```java
public class Demo {
    public static void main(String[] args) {
        // 打印3 / 0的结果
        System.out.println(3 / 0);
        // 输出Exception in thread "main" java.lang.ArithmeticException: / by zero

        // 打印3.5 / 0的结果
        System.out.println(3.5 / 0);
        // 输出Infinity

        // 打印-3.5 / 0的结果
        System.out.println(-3.5 / 0);
        // 输出-Infinity

        // 运算 -2 的平方根
        System.out.println(Math.sqrt(-2));
        // 输出NaN
    }
}
```

## 3.字符型

字符型（char类型）原本用于表示单个字符，但现在有些Unicode字符需要两个char值表示。char类型使用单引号`'`表示，如`char c = 'A';`。char类型的值可以表示为十六进制值，取值范围是`\u0000 ~ \uFFFF`。

除了`\u`这样的转义，还有一些常用的转义符号：

| 转义符号 | 名称  | 转义符号 | 名称  |
| ---- | --- | ---- | --- |
| \b   | 退格  | \f   | 换页  |
| \t   | 制表符 | \\"  | 双引号 |
| \n   | 换行  | \\\  | 反斜线 |
| \r   | 回车  | \s   | 空格  |

注意这里的`\u`可能会与注释产生冲突，如：

```java
// C:\users
// \u00A 是换行的转义表示
```

上面两个注释在Java中都会报错，分别是因为`\u`后面没有接十六进制，不是可识别的转义表示；`\u00A`被直接解析成换行，导致后续内容识别成位定义的代码语句。想要解决这个问题其实也很简单，使用`/*  */`这样的注释就可以了。

> UTF-16编码采用不同长度的代码表示所有Unicode码点（code point，指某个字符对应的代码值）。在基本多语言平面中，每个字符用16位表示，通常称为**代码单元（codeunit）**；而辅助字符编码为一对连续的代码单元。采用这种编码对表示的每个值都属于基本多语言平面中未用的2048个值范围，通常称为**替代区域（surrogatearea）**（U+D800～U+DBFF用于第一个代码单元，U+DC00～U+DFFF用于第二个代码单元）。这样设计十分巧妙，因为我们可以很快知道一个代码单元是一个字符的编码，还是一个辅助字符的第一或第二部分。例如，𝕆是八元数集的数学符号，码点为U+1D546，编码为两个代码单元U+D835和U+DD46。（关于编码算法的具体描述见 https://tools.ietf.org/html/rfc27810 ）。
> 在Java中，char类型描述了采用UTF-16编码的一个代码单元。强烈建议不要在程序中使用char类型，除非确实需要处理UTF-16代码单元。最好将字符串作为抽象数据类型来处理。
> ——《Java核心技术（原书第12版，机械工业出版社）》P32

## 4.布尔类型

布尔类型（boolean）有两个值：`false`和`true`，用于逻辑判断。整型值与布尔值之间不能转换。

> 因此在C/C++中常用的`while(n--)`在Java中就行不通了，因为Java中的`n--`作为整型数据无法转换成布尔值。不过也有好处，至少避免了不小心写出`if (n = 0)`而使得这段代码永远为`false`的情况了（我本人经常不小心写错…）

## 5.枚举类型

在编写程序时，我们通常需要给一些成组的数据编号，如一周的七天编号为1~7、方向的上下左右编号为1~4、尺寸的小中大号编号为1~3等。这样做有两个缺点：

- 对不熟悉程序的人来说，看到突然出现的编号（magic number,魔法数字）会造成困扰，如`if (direction == 3)`，这样意义不明的表达会降低代码的可读性，在协作开发时造成一些麻烦。
- 有时编号可能会由于一些错误原因超出范围，使得程序出现意料之外的情况，难以进行管理和限制。

为了解决这些麻烦，人们提出了 **枚举(enum)** 这样的概念，通过给予一组编号有意义的名称来进行管理，有效缓解了代码可读性与范围限制的问题：

```java
enum size { small, medium, large, extra_large};

size s = size.medium;
```

size类型的变量s只能存储上面声明的一些枚举值，或者是`null`，表示这个变量没有设置任何值。

# 五、整型与常量

## 1.声明变量

变量的声明通常需要先指定类型，然后是这个变量的名称。如：

```java
int a;
double money;
boolean is_done;
```

## 2. 变量的赋值

可以在变量声明后为其赋值，也可以在声明的同时直接赋予初始值，这一点与大多数编程语言相同。

```java
int a;
a = 1;
int a = 1;
```

从Java 10开始，局部变量可以使用`var`声明，这样编译器能够通过初始值自动判断变量的类型，如：

```java
var month = 7;
var name = "Xiao Ming";
```

赋值语句也是一个表达式，其值等于被赋予的数值，如`int a = 3`这个表达式的值为3。
## 3.常量

在Java中，使用`final`来声明一个常量。尽管`const`作为Java的保留字（目前没有使用为关键字，但保留以后使用的可能性），但是目前仍然只能使用`final`来定义常量。常量只能被赋值一次，后面无法进行修改。通常对常量采取全大写的命名方式。如：

```java
final PI = 3.1415926;
```

如果想定义一个常量以在同一个类的多个方法中使用，可以使用关键字`static final`将其设置为一个类常量。

```java
public class ConstDemo
{
    public static final double CM_PER_INCH = 2.54;   // 英寸 - 厘米 换算关系

    public static void main (String[] args) {
        double inchs = 3.25;
        System.out.println(inchs + "英寸等于" + inchs * CM_PER_INCH + "厘米");
    }
}

// 输出：3.25英寸等于8.255厘米
```

类常量的定义通常位于main方法的外部。当其被声明为public时，其他类也可以访问到这个常量。

# 六、算数逻辑运算

## 1.算术运算符

与很多编程语言相同，Java也使用`+ - * /`来完成四则运算，其中两个整数相除会进行整除操作，得到的是结果的整数部分；有浮点数参与除法运算时，得到的是完整的商值。整数的求余（也称为取模）运算使用`%`。

需要注意的是，前面提到Java中整数被0除会产生一个除零异常；浮点数被0除会得到无穷大或者NaN的结果。

## 2. Math类

我们经常需要进行一些数学运算，如求幂、计算三角函数、使用圆周率pi、自然对数e等。Math类很好地完成了这些工作，我们只需调用相关的属性或方法即可：

| 属性/方法             | 描述                                                        |
| ----------------- | --------------------------------------------------------- |
| Math.sqrt(x)      | 求x的平方根                                                    |
| Math.pow(x, a)    | 求x的a次幂                                                    |
| Math.sin(x)       | 计算 `x`（弧度）的正弦值（sine），返回值范围 `[-1, 1]`。                     |
| Math.cos(x)       | 计算 `x`（弧度）的余弦值（cosine），返回值范围 `[-1, 1]`。                   |
| Math.tan(x)       | 计算 `x`（弧度）的正切值（tangent），返回值范围是全体实数。                       |
| Math.atan(x)      | 计算 `x` 的反正切值（arctangent），返回弧度值，范围 `[-π/2, π/2]`。          |
| Math.atan2(y, x)  | 计算 `y/x` 的反正切值（arctangent），返回弧度值，范围 `[-π, π]` ，能正确处理象限问题。 |
| Math.toRadians(d) | 将角度制的`d`转换成弧度制                                            |
| Math.exp(x)       | 计算 $e^{x}$，当 `x` 很大或很小时会返回 `Infinity` 或 `-Infinity`       |
| Math.log(x)       | 计算 $ln(x)$，当 `x <= 0` 时会返回 `NaN`                          |
| Math.log10(x)     | 计算 $log_{10}x$，当 `x <= 0` 时会返回 `NaN`                      |
| Math.PI           | 接近圆周率π的常量，值约为3.1415926                                    |
| Math.E            | 接近自然常数e的常量，值约为2.71828                                     |

如果在一段程序中需要大量使用Math类的属性或方法，可以在程序的头部添加引入Math类的声明即可，需要使用时直接写对应的属性或方法即可：

```java
import static java.lang.Math.*;

final π = PI;
System.out.println("sin(20)的值为：" + sin(20));
```

另外，Math类中的floorMod方法保证了余数不为负，这在一些进位处理中有很大的帮助，例如我们处理一个分钟的迭加逻辑时，会采用 `int currentMin = (oldMin + addMin) % 60;` 这样的写法，但是当 `addMin` 为负时，`currentMin` 也可能会减少到负值，需要额外的逻辑来规范处理，但是Java中可以这样解决：

```java
int currentMin = floorMod(oldMin + addMin, 60);
```

这样就会保证 `currentMin` 的值始终在`0 ~ 59` 之间。

## 3.数据类型转换

![](20250818125310312.png#sc)

上图示意了Java中的数据类型转换关系，其中实线箭头表示转换时无精度损失；虚线箭头则表示可能会发生精度损失。与大多数编程语言相同，将两个不同类型的数据用于算术运算时，Java会自动转换成较大数据类型，如 `int + double -> double`、`int + long -> long`。

需要手动转换数据类型时，可以使用**强制类型转换（cast）**。例如 `int a =  (int) 3.76` 。需要注意以下两点：

- 当前数值超过目标类型的表示范围时会发生截断，即会得到一个不同的数值。例如 `(byte) 300 == 44`。
- 不要试图直接将布尔类型的值转换成数值，应该使用三元表达式 `b ? 1 : 0` 进行转换。

Java支持二元运算符，可以使用`+=`、`-=`这样的符号。如果运算符右侧的数值与左值的类型不同，会发生强制类型转换，即如果对`int`类型的`x`执行`x+=3.5`的操作，得到的结果是`(int) x + 3.5`，即结果为3。

## 4.自增与自减运算符

与C/C++类似，Java支持 `++` 和 `--` 这两个自增/减运算符，并且同样可以前置和后置。

```java
int a = 3;
int b = a++;  // 先取值再++，此时 b == a == 3, a == 4;
int c = ++a;  // 先++再取值，此时 c == a+1 ==  5, a == 5;
```

## 5.逻辑运算符

Java采用了C++的做法，使用 `==` 判断两边是否相等；分别使用 `&&` 、 `||` 、 `！` 表示逻辑与、逻辑或和逻辑非，`!=` 表示不等于，`>`、`<`、`<=`、`>=`这样司空见惯的比较符号更是无需多言了。

需要注意的是，Java中同样存在**逻辑短路**的机制，即不会计算逻辑与在一端为 `false` 情况下、逻辑或在一端为 `true` 情况下，多余的表达式结果。例如：

```java
if (x!=0 && 1 / x > x + y) {
	// 省略
}
```

这个判断中，如果 `x` 为0时，逻辑与运算的左边为0，无论右边是否为真都不会使得整个表达式为真，所以不会计算右边的表达式，也正好就避免了发生除零异常。

## 6.位运算符

指定两个整数进行位运算时，实现的是两个数字的**按位运算**（先转换成二进制表达，然后从低位开始逐位运算）。类似地，Java也是用下面几个符号来定义按位运算：

- &：按位与（and）
- |：按位或（or）
- ^：按位异或（xor）
- ~：按位非（not）
- <<：左移操作
- >>：右移操作，高位以符号位补充，又称算数移位
- >>>：右移操作，高位以0补充，又称逻辑移位

## 7.条件运算符（三元表达式）

```java
条件 ? 条件为真的操作 : 条件为假的操作;
```

（有人用`x == y ? x : y`描述自己作为`x`的"家庭地位"，感觉挺有意思的，大家可以仔细揣摩一下…）

## 8.运算符优先级

一般情况下，为了避免出现优先级问题，在复杂逻辑中添加括号明确定义运算顺序即可，不过要注意以下几点：

- 括号的优先级是最高的，会最先处理最内层括号的内容
- `+=`系列的优先级是**从右向左**，即`a += b += c`的处理顺序是`a += (b += c)`，先处理`b += c`,即 `b = b + c`,然后把现在 `b` 完成加法操作之后的值加到 `a` 上。除此之外，`+=` 这个系列的符号也是**从右往左**处理的。
- `&&`的优先级高于 `||`。

